---
title: JavaScript 闭包
---

# ![javascript](https://zhuye-1308301598.file.myqcloud.com/icons/javascript.png) JavaScript 闭包

写这篇的原因是在搜索讲述闭包的Blog时发现垃圾文章太多了，索性自己从源头开始一点一点捋一下。

要想理解闭包，其实涉及到许多相关的知识，对于额外的知识这里也给出一些初步的介绍。

## 闭包的现代定义

### MDN定义JavaScript中的闭包

函数和对其周围状态**（lexical environment，词法环境）**的引用捆绑在一起构成**闭包（Closure）**。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript中，每当函数被创建，就会在函数生成时产生闭包。

### 通俗理解

- **函数**和**环境**一起称为闭包，其中

- - **函数**是包含**自由变量**的函数；
  - **环境**是为所有函数中自由变量都提供了**绑定值**的环境；



## JavaScript中的闭包

本节主要借鉴自 [Lexical Environment - javascript.info](https://javascript.info/closure#lexical-environment)

要理解JavaScript中的闭包，就要从词法环境（Lexical Environment）讲起。

### 词法环境

- 在JavaScript中，每一个函数、{...} 代码块以及整个脚本文件本身都有一个内建的（隐藏的）对应的对象，这个对象被称为**词法环境（Lexical Environment）**。
- 词法环境包含两部分：

- - 环境记录（Environment Record）：一个将所有本地变量都存储为自身属性的对象（当然也会存储一些其他的东西，例如`this`等）
  - 一个对于（外部代码的）词法环境的引用。



#### 变量

- 变量的本质上是 `Environment Record` 这个**特殊的内建对象的一个属性**。
- 要**获取某个变量的值**或是**修改变量的值**，本质上就是要**获取** `Environment Record` **这个对象的某个属性的值**或是**修改** `Environment Record` **这个对象的某个属性的值**。

- 在下面这段不包含任何函数的代码中，只有一个词法环境

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589523085579-b1619c2e-d783-4655-82d6-c6a6cc3f680e.png)

- 这也是**全局词法环境**，对应的是**由全部代码组成的整个脚本**。
- 在上面的例子中，**矩形**表示一个**环境记录**，**箭头**表示**对于外部词法环境的引用**。由于全局词法环境**不存在对外部的引用**，因此箭头指向了 `null`。

- 随着代码的执行，词法环境也在发生着变化。
- 下面是一段加长版的代码示例：

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589523957143-41ac0418-31fe-4da0-ae9d-aa8eed720bcd.png)

- 右侧的几个矩形阐释了在代码执行的过程中，词法环境发生了什么变化：

1. 当代码开始执行时，词法环境**首先会登记所有被声明的变量**

- - 最初的时候，这些变量都都处于 `Uinitialized` 这个状态。这是一个非常特殊的状态，这意味着JS引擎已经知道有这么一个变量，但是在没使用 `let` 关键字声明之前这个变量是无法被使用的。所以看起来这个变量似乎并不存在一样。

1. 然后执行到了 `let phrase`，因为还没有对 `phrase` 赋值，因此它的值为 `undefined`，现在我们已经可以使用这个变量了。
2. `phrase` 被赋值为 `"Hello"`。

1. `phrase` 的值被修改为 `"Bye"`。

- 一切看起来似乎都如此简单，是不是？



【小结】

- **变量**是一个**特殊的内建对象的一个属性**，这个对象对应着某个**代码块**/**函数**/**全部代码组成的整个脚本**；
- **操作变量**本质上是**操作这个对象的属性**；

**词法环境**是一个仅存在于JS语言规范中的对象，它只是理论上存在于ECMA-262规范中，用来解释事情是如何运作的。我们在代码中无法直接对其进行操作。

JS引擎也会对它进行一系列的优化，丢弃那些未被使用的变量来节省内存并给其他操作腾出空间，同时保证代码的行为不会受到任何影响。



#### 函数定义

- 与变量一样，函数也是一个值。
- 区别在于，函数的声明**在代码执行刚开始就会被立即初始化完成**。

- 当一个词法环境被创建时，函数声明会立即变成一个**随时可用的函数**（不像let，必须到声明的代码后才能使用）。
- 所以我们可以在函数声明之前就可以使用这个函数。

- 例如，我们在代码中加入一个函数，全局词法环境的初始状态如下图所示。

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589525070210-ccb57a65-20bf-4fc7-a607-419489691ee7.png)

- 当然，这个规则只适用于函数声明。**当我们把一个函数表达式使用 let 赋值给一个变量时，这个规则就不再适用了**。



#### 内部和外部词法环境

- 当函数被调用开始运行时，一个词法环境对象会被创建，其中会存储着函数中使用了的**本地变量**和**函数参数值**。
- 例如，对于 `say("John")`，这段代码在执行时词法环境的情况如下图所示：

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589525517563-5ebe6adb-4378-445f-8208-f48b87a6dda5.png)

- 在函数调用时，存在着两个词法环境，一个是内部词法环境（对应着当前函数调用），另一个是外部（全局）词法环境（对应着包含所有代码的整个脚本）：

- - **内部词法环境对象**对应着当前这个 `say` 函数的调用，它只有一个 `name` 属性（函数的参数）。因为我们的代码是 `say("John")`，所以 `name` 参数的值是 `"John"`。
  - **外部词法环境**是**全局词法环境**，它包含一个 `phrase` 属性和 `say` 函数。

- **内部词法环境有一个指向外部词法环境的引用**。
- **当函数要访问某个变量时，会首先在内部词法环境中寻找；如果没找到，会继续去外部词法环境找；如果还是没找到，就再往外还往外一直往外找，直到抵达全局词法环境。**

- 如果最后还是没找到的话，在严格模式（strict mode）下就会报错
- 在刚才的例子中，查找路径如下图所示：

- - 对于 `name` 变量，`say` 函数中的alert 函数在内部词法环境中直接就找到了它。
  - 当 `alert` 试图访问 `phrase` 时，由于内部词法环境中没有 `phrase`，所以它会通过引用链去外部的词法环境中查找，然后它找到了！

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589525813982-872ed2fe-a3f3-4823-bc0f-ea99771dd7cb.png)

#### 函数作为返回值

- 我们看下面一段代码：

```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

- 每次调用 `makeCounter()` 刚开始的时候，一个新的词法环境对象会被创建，用来存储 `makeCounter` 在运行时所需的变量。
- 所以那段代码中有两个嵌套的词法环境，如图所示：

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589526275064-edde826c-53f5-4fd0-b1ce-0a8fe146c814.png)

- 不同的是，在makeCounter() 函数执行的过程中，return count++ 这一行代码也会创建一个微小的词法环境。注意哦，仅仅是创建，并未执行。
- 所有的函数都会记住他们是在哪个词法环境被创建的。这其实没什么神奇的，所有函数都有一个隐藏的属性，名为 `[[Environment]]`，里面存放着函数创建时对应的词法环境的引用。

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589526547710-777de3f9-07df-401f-bcb9-7ea7f1f83a31.png)

- 所以，`counter.[Environment]]` 中存放了对于 `{count: 0}` 这个词法环境的引用。这样的话，无论在何处调用函数，它都能找到自己在哪里被创建的。函数的 `[[Environment]]` 中的值在函数声明时一次设定，终身有效。
- 之后，在我们调用 `counter()` 的时候，这次调用会创建一个新的词法环境，它的**外层词法环境引用**的值会从 `counter.[[Environment]]` 中获取。

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589526970999-62cdae40-38f8-47ad-ae28-6149d58c3bb8.png)

- 现在，当 counter 函数内部需要使用 count 这个变量时，它会首先在自己的词法环境（空的，啥也没有）中去寻找，然后再去外层的 makeCounter() 的词法环境中去寻找。找到了并修改了 count 变量的值。
- 变量只会在它所在的词法环境中被修改更新。

- 代码全部执行完之后，状态如下图所示：

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1589527103011-445d0420-a84d-4485-9ba2-630477cccffd.png)

- 如果我们多次调用 `counter()` 函数， `count` 变量的值会不断发生变化。



### 词法环境和闭包

- **在JavaScript中，所有的函数都是天生的闭包！（只有一个** [**new Function**](https://javascript.info/new-function) **例外）**
- 每个函数会自动创建一个隐藏的 `[[Environment]]` 属性，这个属性的值存放着函数在被创建时对应的**词法环境对象**的引用。

- 这样的话，每次调用函数时，**函数实例**和**它的** `[[Environment]]` **隐藏属性所存放的一个词法环境对象**就**构成了一个闭包**。
- 每一个词法环境中，包含**当前词法环境中定义的变量和方法**等，同时也包含一个**对于外部**（上一级）**词法环境的引用**。这样的话，当我们使用了一个变量时，如果当前词法环境中没有找到，就会去外层继续寻找，直到**找到**或者**到达全局词法环境**。

- 这样的机制在形式上看起来就是“**函数可以访问它的作用域外的变量**”，但是究其本质，这样的技术是通过**对每一个函数增加** `[[Environment]]` **属性从而构建闭包**来实现的。



## 从溯源角度理解闭包

之所以会有这样一段，是因为我在查找闭包概念的定义时发现一个有趣的现象，我查阅了大量的书籍和在线资料，发现他们对于闭包的定义之间存在很大的差别，所以索性从源头探究一下闭包。

读完这段你会看到，闭包并不是一种语言结构，也不是一种实现词法作用域的特定技术（即一个函数可以访问它作用域外的变量），这些都只是闭包的一种形式，而不是闭包本身！



### 1964，诞生

- 我们在维基百科上搜索**闭包（Closure）**的概念可以看到，**闭包**这个名词最早是由P. J. Landin在1964年完成的一篇名为[《The Mechanical Evaluation of Expressions》](https://academic.oup.com/comjnl/article/6/4/308/375725)的论文中提出的。
- 在这篇论文中，对于**闭包**，他首先给出了一个粗略的描述：

... called a "closure", comprising the λ-expression and the environment relative to which it was evaluated. ...

“闭包”包含了一个匿名函数（λ-expression）和它所被用于计算的相关环境。

- 接着，他又给出了一个更为精确地描述：

a closure has:

an environment part which is a list whose two items are:

(1) an environment

(2) an identifier or list of identifiers

and a control part which consists of a list whose sole item is an AE.

“闭包”包含：

一个“环境部分”，环境部分中有两项，分别是：

(1) 一个环境

(2) 一个标识符或一系列的标识符

以及一个“控制部分”，控制部分中包括一个由且仅由一系列应用表达式（AE即applicative expression）    组成的列表；

- 我们用思维导图表示一下

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587972186018-627123ab-2df8-4d65-90e1-cbc036fa7db1.png)

- AEs可能比较难理解，原文中是这样说的

An **AE** denotes something as long as we know the value of each identifier that occurs free in it, and provided also that the expression does not associate any argument with a function that is not applicable to it.

- **Environment**对应的就是**环境（或它的子集）**，**Identifier(s)**对应的就是**被约束的变量（们）**，**AEs**对应的就是**被闭合的表达式**。
- 所以此处闭包可以大致理解为**定义一个可以使得表达式中所有变量都受到约束的环境**。

- 结合下面👇关于Lambda演算的理解，相信相信你会对这段话有更加深刻的理解，不妨一会再回头来看看。



### 1941，孕育

这一部分借鉴了[λ演算 - 维基百科](https://zh.wikipedia.org/wiki/Λ演算)和[你真的理解闭包和Lambda表达式吗？ - Altsuki](https://www.jianshu.com/p/c22db2a91989)，非常感谢他的这篇文章，总结的特别棒，建议大家去看看！

- 关于闭包的思想其实最早可以追溯到**Lambda演算**（1941年由Alonzo Church发表）。
- 下面我们从Lambda演算开始一步一步揭开闭包的面纱。

#### Lambda演算规则

- Lambda演算可以被认为是一种非常简单的编程语言，它使用以下一些规则来构建Lambda项：

| **语法** | **名称** | **描述**                           | **注释**                                               |
| -------- | -------- | ---------------------------------- | ------------------------------------------------------ |
| a        | **变量** | 表示参数或数学逻辑值的字符或字符串 |                                                        |
| (λx.M)   | **抽象** | 函数定义M是一个表达式，x是绑定参数 | 可以通过绑定参数x将表达式M转换为一个期望一个参数的函数 |
| (f x)    | **应用** | 将一个表达式应用到另一个表达式     | 可以看成是函数调用                                     |

本质就是先构建Lambda项，再进行归约操作。

- 上面👆的规则可能有些太过于抽象，下面我们使用一个例子🌰来理解一下规则。 

| **规则类型** | **数学描述** | **Lambda演算语法** | **JS语法实现**  |
| ------------ | ------------ | ------------------ | --------------- |
| **变量**     | x            | x                  | x               |
| **抽象**     | f(x) = x + 2 | (λx.x+2)           | x => x + 2      |
| **应用**     | f(7)         | ((λx.x+2) 7)       | (x => x + 2)(7) |

- 例如函数f(x) = x+2使用Lambda演算的**抽象规则**可一个表示为 `(λx.x+2)` ，表示包含一个表达式`x+2`，其中的`x`是一个绑定变量，可以使用你提供的值作为参数来替换。
- 而f(7)使用Lambda演算的**应用规则**可以表示为 `((λx.x+2) 7)` 就是用`7`来替换`x+2`中的`x`，得到`7+2`，再通过简单的算数规则得到结果`9`。

JavaScript中的箭头函数（匿名函数）就是一个非常清晰的Lambda演算的描述。



#### Lambda表达式的本质

- 了解了Lambda演算的规则后，其实答案显而易见了
- Lambda表达式本质上就是一个**匿名函数**（心细的你可能也已经发现了，在维基百科上点击**λ-expression**会自动跳转到**匿名函数（Anonymous Function）**的词条）。



#### Lambda演算与闭包

##### 0. 开始理解闭包

- 理解了Lambda表达式的本质，是时候来从这个角度理解一下**闭包**了。
- 不过首先要深入看一下刚在我们一直没有关注的Lambda演算规则中的第一条，也就是**变量**。



##### 1. 被约束的变量和自由变量

- 在刚刚的**Lambda抽象规则**中所提到的**被绑定的参数**也被称为**被****约束的（Bound）**。
- 可是如果表达式中存在着为未被绑定的参数时，例如对于表达式`(λx.x+y)`，`x`**是被约束的**，**但是**`y`**却是自由的**。我们从这个表达式中**无法判断y是谁？y从哪来？y要到哪去？**

- 因此**在找出y代表的意义之前，我们无法计算（evaluate）**`x+y` **这个****表达式**。



##### 2. 环境

- 那么问题来了，自由的y究竟是在哪里定义的呢？可以想象到y肯定定义在这个表达式之外的某个地方，在这个表达式的某个邻域内（我们假设y绝对已定义），而这片邻域就是**环境（Environment）**。
- 这个**环境**可能是一个更大的表达式，也可能是表达式的一部分。或在某个库中，或者在语言本身（原生的）。



##### 3. 闭合表达式和开放表达式

- 这样的话，Lambda表达式就可以个分为两类

- - **闭合表达式（CLOSED Expressions）**：表达式中每一个变量（符号）都**受到抽象规则的约束**，即**都是被约束的**。这个表达式自给自足，**不需要评估外部的环境**。例如，`(λx.x+2)`
  - **开放表达式（OPEN Expressions）**：表达式中的某些变量（符号）没有受到约束，**是自由的**。这些自由的变量**需要一些外部信息**才能被计算。例如，`(λx.x+y)`



##### 4. 闭包

- **最关键的来了！！！**你可以**通过定义一个环境来关闭一个开放的Lambda表达式**，在这个环境中，原来开放表达式中的**自由变量（符号）都会受到约束**。也就是说，**表达式中的每一个变量（符号）都会受到约束**，因而**表达式也就变成了一个闭合表达式**。**这就产生了一个闭包！**
- **闭包的概念**：

- - **Lambda表达式的闭包是定义在外部上下文（环境）中特定的符号集，它们给这个表达式中的自由变量（符号）赋值。它将一个开放的、仍然包含一些未定义符号的Lambda表达式变为一个关闭的Lambda表达式，使这个Lambda表达式不再具有任何自由符号。**

- 😃Hey！是不是豁然开朗了呢！



### 1970，重生

这里不打算写太多了，感兴趣的话可以自己查一下资料吧。

- Lisp是世界上第一款函数式编程语言，诞生于1957年。
- 静态作用域（词法作用域）和动态作用域

- - **静态作用域**（**词法作用域**）：变量作用范围取决于在源代码中定义的位置，在词法解析阶段就可以确定。
  - **动态作用域**：变量的调用范围取决于函数调用链。

- 早期Lisp有一个需要解决的问题，也是所有将函数作为“一等公民”的编程语言都需要考虑的问题，即[函数参数问题](https://en.wikipedia.org/wiki/Funarg_problem)（FUNARG Problem）。由于早期的Lisp使用了动态作用域（变量的作用范围取决于函数的调用链），所以在一些方言中不得不使用类似**符号表树**这种东西来解决函数参数问题。

在动态作用域的编程语言中，将函数作为一个参数时，需要将自由变量在一个单独的环境中保存，然后该函数引用这个单独的环境。这样捆绑起来的整体其实也是一个闭包。

- 作为Lisp的方言之一，Scheme是第一个使用了**词法作用域**（**静态作用域**）的Lisp方言。也将**闭包**的概念发扬光大。
- 而JavaScript由于**借鉴了Scheme**中“将**函数作为一等公民**”，再加上**使用词法作用域**，拥有**闭包**就变得理所当然了。我们可以发现，**JavaScript中闭包无处不在**。





【参考资料】

[【MDN】闭包 - JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

[【javascript.info】Variable Scope - Lexical Environment](https://javascript.info/closure#lexical-environment)

[【维基百科】闭包（计算机科学）](https://zh.wikipedia.org/zh-cn/闭包_(计算机科学))

[【Google 学术】The Mechanical Evaluation of Expressions - Petter Ladin](https://academic.oup.com/comjnl/article/6/4/308/375725)

[【维基百科】λ演算](https://zh.wikipedia.org/wiki/Λ演算)

[【简书】你真的理解闭包和Lambda表达式吗？ - Altsuki](https://www.jianshu.com/p/c22db2a91989)