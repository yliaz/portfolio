---
title: 从LHS和RHS角度理解作用域
authors: [zhuye]
tags: [JavaScript]
---

## LHS和RHS

### LHS与RHS的概念

- **LHS**（Left-hand Side）**查询**：赋值操作的**目标（容器）是谁**？（要把值给谁）
- **RHS**（Right-hand Side）**查询**：赋值操作的**源头（值）在哪**？（要从哪里拿到值）

需要注意的是，“赋值操作的左侧和右侧” 不等于 “赋值操作符'='的左侧和右侧”，因为赋值操作还有其他形式

### LHS与RHS的区别

- 二者的**区别**在于**目的不同**：

- - **LHS查询**的目的是试图找**到变量的容器本身**，从而可以**对其赋值**；
  - **RHS查询**的目的是**获取****某个变量的值**； 



## 引擎、编译器和作用域

### ![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587871537137-593766db-ff9d-46d4-913b-dddd71138509.png)引擎

- 从头到尾负责整个JavaScript程序的**编译**及**执行**过程；

### ![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587871520436-cd0a179b-fba2-4edd-81f1-bf6d6294294d.png)编译器

- 负责**语法分析**及**代码生成；**

### ![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587871556428-b5e9386a-4b4e-49c8-aee7-a5de448b1760.png)作用域

- 负责收集并维护由所有声明的标识符（变量）组成的一系列查询。
- 有一套严格的规则，来确定当前执行的代码对这些标识符的访问权限。



## 举个例子 🌰 

- 对于如下一段代码👇

```javascript
let a = 2;
// 分解为
let a;
a = 2;
```

赋值操作符“=”会导致LHS查询。

### 编译时

词法分析 => 语法分析 => 代码生成

- 遇到`let a`，**编译器**会询问**作用域**是否已经有一个该名称的变量存在于同一个作用域的集合中；
- 如果已存在，**编译器**会忽略该声明，继续进行编译；否则会创建一个新的变量，命名为`a`；

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587881907936-8699a5fa-b540-4559-b966-20d4309f8aa3.png)

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587881925024-589f3cd2-e4dc-4826-8b50-3a300288d92b.png)

- **编译器**为**引擎**生成运行时所需要的代码，这些代码用来处理`a = 2`这个赋值操作；



### 运行时

- **引擎**询问当前**作用域**，在当前的作用域集合中是否存在一个叫做a的变量；
- 如果存在，**引擎**就会使用这个变量；如果不存在，**引擎**会（在外层嵌套的作用域中）继续查找（继续询问当前作用域的上一级作用域）；

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587881972525-b44dedaf-39ea-41b9-b2a8-c37cc56b7940.png)

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587881984843-6996ba91-0b62-438c-a203-a29c0e2dc5b9.png)

- 如果最终找到了，**引擎**就会使用这个变量；否则会抛出一个异常。



### 关于作用域嵌套

- 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套，形成了**嵌套作用域链**。
- **遍历**嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。

- 当抵达最外层的全局作用域时，无论是否找到，查找过程都会停止。



## 举个复杂点的例子🌰

- 对于下面的代码👇

```javascript
function foo(a) {
    console.log(a + b);
}
let b = 2;
foo(1);
```

- 上面这段代码在运行时，引擎和作用域会有如下一段对话：

### 对话

![img](https://zhuye-1308301598.file.myqcloud.com/markdown/1587884599715-eb312cba-3086-4992-a8c0-2e5b0340599a.png)

### 关于LHS和RHS的分析

- 那么问题来了，挖掘机技术哪家强？上面那段代码中，究竟有几次LHS查询？又有几次RHS查询？

```javascript
function foo(a) {
    console.log(a + b);
}
let b = 2;
foo(1);
```

- **LHS查询**

- - b = 2
  - a = 1（隐式）

- **RHS查询**

- - foo(...)
  - a+b中的a

- - a+b中的b
  - console



## 异常

- 在变量还没有声明的情况下，这LHS查询和RHS查询的行为是不一样的。
- 不成功的RHS查询会抛出ReferenceError异常。

- 不成功的LHS查询会导致**自动隐式地创建一个全局变量**（非严格模式下），或者**抛出ReferenceError异常**（严格模式下）。