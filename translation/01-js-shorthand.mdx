---
title: 20ä¸ªJSç®€å†™å°æŠ€å·§ï¼ŒåŠ©ä½ é«˜æ•ˆæ•²ä»£ç 
authors: [zhuye]
tags: [JavaScript]
---

import LanguageSwitch from "../src/components/LanguageSwitch";

# ã€è¯‘ã€‘20ä¸ªJSç®€å†™å°æŠ€å·§ï¼ŒåŠ©ä½ é«˜æ•ˆæ•²ä»£ç 

> ä»»ä½•ä¸€ç§ç¼–ç¨‹è¯­è¨€çš„ç®€å†™å°æŠ€å·§éƒ½æ˜¯ä¸ºäº†å¸®åŠ©ä½ å†™å‡ºæ›´ç®€æ´ã€æ›´å®Œå–„çš„ä»£ç ï¼Œè®©ä½ ç”¨æ›´å°‘çš„ç¼–ç å®ç°ä½ çš„éœ€æ±‚ã€‚æ¥ä¸‹æ¥è®©æˆ‘ä»¬é€ä¸€è®¨è®ºä¸€ä¸‹JavaScriptä¸­çš„ä¸€äº›ç®€å†™å°æŠ€å·§ã€‚

<!--truncate-->

<LanguageSwitch />

> - **åŸæ–‡ä½œè€…ï¼š** Amitav Mishra
> - **åŸæ–‡é“¾æ¥ï¼š** [20 JavaScript Shorthand Techniques that will save your time](https://javascript.plainenglish.io/20-javascript-shorthand-techniques-that-will-save-your-time-f1671aab405f)

### 1. å£°æ˜å¤šä¸ªå˜é‡

```javascript
// å¸¸è§„å†™æ³•
let x; 
let y = 20; 

// ç®€å†™
let x, y = 20;
```


### 2. ä¸ºå¤šä¸ªå˜é‡èµ‹å€¼

<- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**æ•°ç»„è§£æ„èµ‹å€¼**ï¼Œä»…ç”¨ä¸€è¡Œä»£ç å®ç°ä¸ºå¤šä¸ªå˜é‡èµ‹å€¼ã€‚ <-
-> We can assign values to multiple variables in one line with array destructuring. ->

```javascript
// å¸¸è§„å†™æ³• 
let a, b, c; 
a = 5; 
b = 8; 
c = 12;
 
// ç®€å†™
let [a, b, c] = [5, 8, 12];
```


### 3. æ°å½“ä½¿ç”¨ä¸‰å…ƒè¿ç®—ç¬¦

<- æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œç”¨ä¸‰å…ƒè¿ç®—ç¬¦ï¼ˆä¹Ÿç§°æ¡ä»¶è¿ç®—ç¬¦ï¼‰èŠ‚çœ5è¡Œä»£ç ã€‚ <-
-> We can save 5 lines of code here with ternary (conditional) operator. ->

```javascript
// å¸¸è§„å†™æ³•
let marks = 26; 
let result; 
if(marks >= 30){
 result = 'Pass'; 
}else{ 
 result = 'Fail'; 
} 
// ç®€å†™
let result = marks >= 30 ? 'Pass' : 'Fail';
```


### 4. æŒ‡å®šé»˜è®¤å€¼

<- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€Œ[OR ( || ) çŸ­è·¯æ±‚å€¼](https://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC)ã€çš„é€»è¾‘ï¼Œæ¥ç»™å®šä¸€ä¸ªé»˜è®¤å€¼ã€‚å½“ `||` æˆ‘ä»¬çš„æœŸæœ›å€¼æ˜¯ä¸€ä¸ªã€Œ[falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)ã€å€¼çš„æ—¶å€™ï¼Œæ•´ä¸ªè¡¨è¾¾å¼çš„å€¼ä¾¿ä¼šå–åˆ°æˆ‘ä»¬ç»™å®šçš„é»˜è®¤å€¼ã€‚ <-
-> We can use OR(||) short circuit evaluation to assign a default value to a variable in case the expected value found falsy. ->

```javascript
// å¸¸è§„å†™æ³•
let imagePath; 
let path = getImagePath(); 
if(path !== null && path !== undefined && path !== '') { 
  imagePath = path; 
} else { 
  imagePath = 'default.jpg'; 
} 

// ç®€å†™
let imagePath = getImagePath() || 'default.jpg';
```


### 5. AND(&&)çŸ­è·¯æ±‚å€¼

<- å¦‚æœä½ åªåœ¨ä¸€ä¸ªå˜é‡ä¸ºçœŸçš„æƒ…å†µä¸‹æ‰è°ƒç”¨æŸä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆä½ å¯ä»¥ç”¨ã€ŒAND(&&)çŸ­è·¯æ±‚å€¼ã€çš„é€»è¾‘æ¥ä»£æ›¿ã€‚ <-
-> If you are calling a function only if a variable is true, then you can use AND(&&) short circuit as an alternative for this. ->

```javascript
// å¸¸è§„å†™æ³•
if (isLoggedin) {
 goToHomepage(); 
} 

// ç®€å†™
isLoggedin && goToHomepage();
```

<- åœ¨Reactä¸­ï¼Œå½“ä½ æƒ³æœ‰æ¡ä»¶åœ°æ¸²æŸ“æŸä¸ªç»„ä»¶æ—¶ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨AND(&&)è¿™ç§ç®€å†™æ–¹å¼ã€‚ä¾‹å¦‚ä¸‹é¢è¿™ä¸ªä¾‹å­ğŸ‘‡ <-
-> The AND(&&) short circuit shorthand is more useful in React when you want to conditionally render a component. For example: ->

```javascript
<div> { this.state.isLoading && <Loading /> } </div>
```

> è¯‘è€…æ³¨ï¼šè¡¨è¾¾å¼çš„å€¼ä¸º0è¿™ç§ç‰¹æ®Šçš„falsyå€¼æ—¶ï¼Œè¯·è°¨æ…è€ƒè™‘ä½¿ç”¨



### 6. äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼

<- å½“æˆ‘ä»¬æƒ³äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼æ—¶ï¼Œç»å¸¸ä¼šé‡‡å–å¼•å…¥ç¬¬ä¸‰ä¸ªå˜é‡çš„æ–¹æ³•ã€‚å…¶å®æˆ‘ä»¬å¯ä»¥é€šè¿‡æ•°ç»„è§£æ„èµ‹å€¼è½»æ¾åœ°äº¤æ¢ä¸¤ä¸ªå˜é‡ã€‚ <-
-> To swap two variables, we often use a third variable. We can swap two variables easily with array destructuring assignment. ->

```javascript
let x = 'Hello', y = 55; 

// å¸¸è§„å†™æ³•ï¼Œå¼•å…¥ç¬¬ä¸‰ä¸ªå˜é‡
const temp = x; 
x = y; 
y = temp; 

// ç®€å†™ï¼Œä½¿ç”¨æ•°ç»„è§£æ„èµ‹å€¼
[x, y] = [y, x];
```


### 7. å–„ç”¨ç®­å¤´å‡½æ•°

```javascript
// å¸¸è§„å†™æ³•
function add(num1, num2) { 
   return num1 + num2; 
} 

// ç®€å†™
const add = (num1, num2) => num1 + num2;
```

> å‚è€ƒ[ã€Œç®­å¤´å‡½æ•°ã€](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)



### 8. æ¨¡æ¿å­—ç¬¦ä¸²

<- æˆ‘ä»¬é€šå¸¸ä½¿ç”¨`+`è¿ç®—ç¬¦æ¥è¿æ¥å­—ç¬¦ä¸²å’Œå…¶ä»–ç±»å‹çš„å˜é‡ã€‚æœ‰äº†ES6æ¨¡æ¿å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ›´ç®€å•çš„æ–¹å¼æ¥ç»„åˆå­—ç¬¦ä¸²ã€‚<-
-> We normally use + operator to concatenate string values with variables. With ES6 template literals we can do it in a more simple way. ->

```javascript
// å¸¸è§„å†™æ³• 
console.log('You got a missed call from ' + number + ' at ' + time); 

// ç®€å†™
console.log(`You got a missed call from ${number} at ${time}`);
```


### 9. å¤šè¡Œå­—ç¬¦ä¸²

<- å¯¹äºå¤šè¡Œå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨+æ“ä½œç¬¦å’Œä¸€ä¸ªæ–°çš„æ¢è¡Œç¬¦ï¼ˆ\nï¼‰æ‹¼æ¥å®ç°ã€‚å…¶å®æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨åå¼•å·ï¼ˆ`ï¼‰æ¥æ›´ç®€å•åœ°å®ç°ã€‚<-
-> For multiline string we normally use + operator with a new line escape sequence (\n). We can do it in an easier way by using backticks (`) ->

```javascript
// å¸¸è§„å†™æ³•
console.log('JavaScript, often abbreviated as JS, is a\n' +             
            'programming language that conforms to the \n' + 
						'ECMAScript specification. JavaScript is high-level,\n' + 
						'often just-in-time compiled, and multi-paradigm.' ); 

// ç®€å†™
console.log(`JavaScript, often abbreviated as JS, is a programming language that conforms to the ECMAScript specification. JavaScript is high-level, often just-in-time compiled, and multi-paradigm.`);
```


### 10. å¤šæ¡ä»¶æ£€æŸ¥

<- å¯¹äºå¤šå€¼åŒ¹é…ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ‰€æœ‰çš„å€¼æ”¾åœ¨æ•°ç»„ä¸­ï¼Œä½¿ç”¨æ•°ç»„æä¾›çš„`indexOf()`æˆ–`includes()`æ–¹æ³•æ¥ç®€å†™ã€‚ <-
-> For multiple value matching, we can put all values in array and use indexOf() or includes() method. ->

```javascript
// å¸¸è§„å†™æ³•
if (value === 1 || value === 'one' || value === 2 || value === 'two') { 
     // æ‰§è¡Œä¸€äº›ä»£ç 
} 

// ç®€å†™1
if ([1, 'one', 2, 'two'].indexOf(value) >= 0) { 
    // æ‰§è¡Œä¸€äº›ä»£ç  
}
// ç®€å†™2
if ([1, 'one', 2, 'two'].includes(value)) { 
    // æ‰§è¡Œä¸€äº›ä»£ç  
}
```


### 11. å¯¹è±¡å±æ€§åˆ†é…

<- å¦‚æœå˜é‡åå’Œå¯¹è±¡çš„å±æ€§åç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨å¯¹è±¡çš„ä¸­åªå†™å˜é‡åï¼Œè€Œä¸ç”¨åŒæ—¶å†™å‡ºå±æ€§åå’Œå±æ€§å€¼ï¼ˆå˜é‡çš„å€¼ï¼‰ã€‚JavaScriptä¼šè‡ªåŠ¨å°†å±æ€§åè®¾ç½®ä¸ºä¸å˜é‡åç›¸åŒï¼Œå¹¶å°†å±æ€§å€¼åˆ†é…ä¸ºå˜é‡å€¼ã€‚ <-
-> If the variable name and object key name is same then we can just mention variable name in object literals instead of both key and value. JavaScript will automatically set the key same as variable name and assign the value as variable value. ->

```javascript
let firstname = 'Amitav'; 
let lastname = 'Mishra'; 

// å¸¸è§„å†™æ³• 
let obj = {firstname: firstname, lastname: lastname}; 

// ç®€å†™ 
let obj = {firstname, lastname};
```


### 12. å­—ç¬¦ä¸²ï¼ˆStringï¼‰è½¬ä¸ºæ•°å­—ï¼ˆNumberï¼‰

<- æœ‰ä¸€äº›å†…ç½®æ–¹æ³•ï¼Œå¦‚ `parseInt` å’Œ `parseFloat` ï¼Œå¯ä»¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ç®€å•åœ°åœ¨å­—ç¬¦ä¸²å€¼å‰é¢æä¾›ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦ `+` æ¥å®ç°ã€‚ <-
-> There are built in methods like parseInt and parseFloat available to convert a string to number. We can also do this by simply providing a unary operator (+) in front of string value. ->

```javascript
// å¸¸è§„å†™æ³•
let total = parseInt('453'); 
let average = parseFloat('42.6'); 

// ç®€å†™
let total = +'453'; 
let average = +'42.6';
```


### 13. å¤šæ¬¡é‡å¤ä¸€ä¸ªå­—ç¬¦ä¸²

<- è¦å°†ä¸€ä¸ªå­—ç¬¦ä¸²é‡å¤æŒ‡å®šçš„æ¬¡æ•°ï¼Œä½ å¯ä»¥ä½¿ç”¨forå¾ªç¯ã€‚ä½†ä½¿ç”¨repeat()æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸€è¡Œä¸­å®Œæˆã€‚<-
-> To repeat a string for a specified number of time you can use a for loop. But using the repeat() method we can do it in a single line. ->

```javascript
// å¸¸è§„å†™æ³•
let str = ''; 
for(let i = 0; i < 5; i ++) { 
  str += 'Hello '; 
} 
console.log(str); // Hello Hello Hello Hello Hello 

// ç®€å†™
'Hello '.repeat(5);
```

> Tip: Want to apologize to someone by sending 100 times â€œsorryâ€? Try it with repeat() method. If you want to repeat each string in a new line, then add \n to the string.
>
> æƒ³å¯¹æŸäººè¯´100æ¬¡å¯¹ä¸èµ·ï¼Ÿè¯•è¯• `repeat()` æ–¹æ³•å§ã€‚å¦‚æœä½ å¸Œæœ›æ¯ä¸€ä¸ªå­—ç¬¦ä¸²å ä¸€è¡Œï¼Œé‚£ä¹ˆå°±åœ¨å­—ç¬¦ä¸²ç»“å°¾æ·»åŠ æ¢è¡Œç¬¦ï¼ˆ `\n`ï¼‰ã€‚

```javascript
// æƒ³è·Ÿä½ è¯´100å£°æŠ±æ­‰ï¼
'sorry\n'.repeat(100);
```


### 14. å¹‚çš„åŠ›é‡ï¼

<- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `Math.pow()` æ–¹æ³•æ¥æ±‚ä¸€ä¸ªæ•°å­—çš„å¹‚ã€‚æœ‰ä¸€ä¸ªæ›´ç®€æ´çš„è¯­æ³•ï¼Œé‚£å°±æ˜¯åŒæ˜Ÿå·ï¼ˆ`**`ï¼‰ã€‚ <-
-> We can use Math.pow() method to find the power of a number. There is a shorter syntax to do it with double asterik (**). ->

```javascript
// å¸¸è§„å†™æ³•
const power = Math.pow(4, 3); // 64 

// ç®€å†™
const power = 4**3; // 64
```


### 15. åŒNOTä½è¿ç®—ç¬¦ï¼ˆ~~ï¼‰ï¼Ÿ

<- åŒNOTä½è¿ç®—ç¬¦ï¼ˆ`~~`ï¼‰æ˜¯ `Math.floor()` æ–¹æ³•çš„æ›¿ä»£å“ã€‚ <-
-> The double NOT bitwise operator is a substitute for Math.floor() method. ->

```javascript
// å¸¸è§„å†™æ³•
const floor = Math.floor(6.8); // 6 

// ç®€å†™
const floor = ~~6.8; // 6
```

> Improvement from comment by Caleb: 
> The double NOT bitwise operator approach only works for 32 bit integers i.e (2**31)-1 = 2147483647. So for any number higher than 2147483647, bitwise operator (~~) will give wrong results, so recommended to use Math.floor() in such case.**
>
> **æ„Ÿè°¢Calebçš„æé†’ï¼š
> åŒNOTä½è¿ç®—ç¬¦æ–¹æ³•**åªé€‚ç”¨äº32ä½æ•´æ•°**ï¼Œå³(2**31)-1=2147483647ã€‚æ‰€ä»¥å¯¹äºä»»ä½•å¤§äº2147483647çš„æ•°å­—ï¼Œä½è¿ç®—ç¬¦(~~)ä¼šç»™å‡ºé”™è¯¯çš„ç»“æœï¼Œæ‰€ä»¥å»ºè®®åœ¨è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨Math.floor()ã€‚



### 16. æ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å¤§æœ€å°å€¼

<- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨forå¾ªç¯æ¥éå†æ•°ç»„ï¼Œæ‰¾åˆ°æœ€å¤§å€¼æˆ–æœ€å°å€¼ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨Array.reduce()æ–¹æ³•æ¥å¯»æ‰¾æ•°ç»„ä¸­çš„æœ€å¤§å’Œæœ€å°å€¼ã€‚ <-
-> We can use for loop to loop through each value of array and find the max or min value. We can also use the Array.reduce() method to find the max and min number in array. ->

<- ä½†æ˜¯ä½¿ç”¨å±•å¼€æ“ä½œç¬¦ï¼ˆ`...`ï¼‰æˆ‘ä»¬å¯ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€è¡Œä»£ç å°±å®ç°è¿™ä¸ªéœ€æ±‚ã€‚<-
-> But using spread operator we can do it in a single line. ->

```javascript
// ç®€å†™
const arr = [2, 8, 15, 4]; 
Math.max(...arr);  // æœ€å¤§å€¼ 15 
Math.min(...arr);  // æœ€å°å€¼ 2
```


### 17. å…³äºForå¾ªç¯

<- è¦éå†ä¸€ä¸ªæ•°ç»„ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨ä¼ ç»Ÿçš„ `for` å¾ªç¯ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ `for...of` çš„æ–¹å¼æ¥éå†ä¸€ä¸ªæ•°ç»„ã€‚å¦‚æœè¦è®¿é—®æ•°ç»„æ¯ä¸ªå€¼çš„ç´¢å¼•ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `for...in` å¾ªç¯ã€‚ <-
-> To loop through an array we normally use the traditional for loop. We can make use of the for...of loop to iterate through arrays. To access the index of each value we can use for...in loop. ->

```javascript
let arr = [10, 20, 30, 40]; 

// å¸¸è§„å†™æ³•ï¼Œforå¾ªç¯
for (let i = 0; i < arr.length; i++) { 
  console.log(arr[i]); 
} 

// ç®€å†™

// for...ofå¾ªç¯
for (const val of arr) { 
  console.log(val); 
} 

// for...inå¾ªç¯
for (const index in arr) { 
  console.log(`index: ${index} and value: ${arr[index]}`); 
}
```

<- æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ `for...in` å¾ªç¯æ¥éå†å¯¹è±¡çš„å±æ€§ã€‚<-
-> We can also loop through object properties using for...in loop. ->

```javascript
let obj = {x: 20, y: 50}; 
for (const key in obj) { 
  console.log(obj[key]); 
}
```

> å‚è€ƒï¼š[JavaScriptä¸­éå†å¯¹è±¡å’Œæ•°ç»„çš„å‡ ç§ä¸åŒçš„æ–¹å¼](https://jscurious.com/different-ways-to-iterate-through-objects-and-arrays-in-javascript/)



### 18. åˆå¹¶æ•°ç»„

```javascript
let arr1 = [20, 30]; 

// å¸¸è§„å†™æ³•
let arr2 = arr1.concat([60, 80]); 
// [20, 30, 60, 80] 

// ç®€å†™
let arr2 = [...arr1, 60, 80]; 
// [20, 30, 60, 80]
```


### 19. å¤šå±‚æ¬¡å¯¹è±¡çš„æ·±æ‹·è´

<- è¦å¯¹ä¸€ä¸ªå¤šå±‚æ¬¡çš„å¯¹è±¡å®ç°æ·±æ‹·è´ï¼Œæˆ‘ä»¬å¯ä»¥éå†å…¶æ¯ä¸ªå±æ€§ï¼Œæ£€æŸ¥å½“å‰å±æ€§æ˜¯å¦åŒ…å«ä¸€ä¸ªå¯¹è±¡ã€‚å¦‚æœæ˜¯ï¼Œåˆ™é€’å½’è°ƒç”¨åŒä¸€ä¸ªå‡½æ•°ï¼Œå¹¶å°†å½“å‰å±æ€§å€¼ï¼ˆå³åµŒå¥—å¯¹è±¡ï¼‰ä½œä¸ºå‡½æ•°çš„å‚æ•°ä¼ é€’è¿›å»ã€‚<-
-> To deep clone a multi-level object, we can iterate through each property and check if the current property contains an object. If yes, then do a recursive call to the same function by passing the current property value (i.e. the nested object). ->

<- å¦‚æœæˆ‘ä»¬çš„å¯¹è±¡ä¸åŒ…å«**å‡½æ•°**ã€**undefined**ã€**NaN**æˆ–**Date**ç­‰å€¼ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ `JSON.stringify()` å’Œ `JSON.parse()` æ¥å®ç°ã€‚<-
-> We can also do it by using JSON.stringify() and JSON.parse() if our object doesn't contains functions, undefined, NaN or Date as values. ->

<- å¦‚æœæˆ‘ä»¬çš„å¯¹è±¡æ˜¯å•å±‚å¯¹è±¡ï¼Œå³æ²¡æœ‰åµŒå¥—å¯¹è±¡ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨å±•å¼€æ“ä½œç¬¦ï¼ˆ`...`ï¼‰è¿›è¡Œæ·±æ‹·è´ã€‚<-
-> If we have single level object i.e no nested object present, then we can deep clone using spread operator also. ->

```javascript
let obj = {x: 20, y: {z: 30}}; 

// å¸¸è§„å†™æ³•ï¼Œé€’å½’
const makeDeepClone = (obj) => { 
  let newObject = {}; 
  Object.keys(obj).map(key => { 
    if(typeof obj[key] === 'object'){ 
      newObject[key] = makeDeepClone(obj[key]); 
    } else { 
      newObject[key] = obj[key]; 
    } 
  }); 
 return newObject; 
} 
const cloneObj = makeDeepClone(obj); 

// ç‰¹æ®Šæƒ…å†µä¸‹(å¯¹è±¡ä¸­å±æ€§å€¼æ²¡æœ‰å‡½æ•°ã€undefinedæˆ–NaNçš„æƒ…å†µä¸‹)çš„ç®€å†™
const cloneObj = JSON.parse(JSON.stringify(obj));

// å•å±‚å¯¹è±¡ï¼ˆæ— åµŒå¥—å¯¹è±¡ï¼‰æƒ…å†µä¸‹çš„ç®€å†™
let obj = {x: 20, y: 'hello'};
const cloneObj = {...obj};
```

> æ„Ÿè°¢è¯„è®ºåŒºä¸­çš„æé†’ï¼š
> å¦‚æœä½ çš„å¯¹è±¡å±æ€§ä¸­åŒ…å«**å‡½æ•°**ã€**undefined**æˆ–**NaN**ä½œä¸ºå±æ€§å€¼æ—¶ï¼Œ**JSON.parse(JSON.stringify(obj)) **è¿™ç§ç®€å†™å°†ä¼šå¤±æ•ˆã€‚å› ä¸ºå½“ä½ å¯¹å¯¹è±¡è¿›è¡Œ **JSON.stringify** æ—¶ï¼ŒåŒ…å«å‡½æ•°ã€undefinedæˆ–NaNä½œä¸ºå€¼çš„å±æ€§ä¼šä»å¯¹è±¡ä¸­è¢«åˆ é™¤ã€‚
> æ‰€ä»¥å½“ä½ çš„å¯¹è±¡åªåŒ…å«å­—ç¬¦ä¸²å’Œæ•°å­—æ—¶ï¼Œæ‰å¯ä»¥ä½¿ç”¨ **JSON.parse(JSON.stringify(obj))** ã€‚



> å‚è€ƒï¼š[JSON.parse() å’Œ JSON.stringify()](https://jscurious.com/difference-between-json-parse-and-json-stringify/)



### 20. è·å–å­—ç¬¦ä¸²ä¸­çš„æŸä¸ªå­—ç¬¦

```javascript
let str = 'jscurious.com'; 

// å¸¸è§„å†™æ³•
str.charAt(2); // c 

// ç®€å†™
str[2]; // c
```

<- **è¿™äº›ç®€å†™å°æŠ€å·§ä¸­çš„ä¸€äº›ä¼¼ä¹ä¸å¤ªé€‚åˆåœ¨é¡¹ç›®ä¸­ä½¿ç”¨ï¼Œä½†çŸ¥é“æ€»æ¯”ä¸çŸ¥é“å¼ºã€‚** <-
-> Some of these shorthand techniques may not seems relevant to use in project but itâ€™s not bad to know some extra techniques.  ->

<- **å¥½ç¼–ç ï¼Œç¼–å¥½ç ï¼Œç¼–ç å¥½ï¼** <-
-> Happy coding! ->



### ã€é™„ã€‘ä¸“æœ‰åè¯æ€»ç»“ï¼š

|         **ä¸­æ–‡**         |            **è‹±æ–‡**            |
| :----------------------: | :----------------------------: |
|         ç®€å†™æŠ€å·§         |      shorthand techniques      |
|           èµ‹å€¼           |          assign value          |
|       æ•°ç»„è§£æ„èµ‹å€¼       | array destructuring assignment |
|        æ¡ä»¶æ“ä½œç¬¦        |      conditional operator      |
|        å±•å¼€æ“ä½œç¬¦        |        spread operater         |
|          æ·±æ‹·è´          |           deep clone           |
|          æœŸæœ›å€¼          |         expected value         |
|         å¤šå€¼åŒ¹é…         |    multiple value matching     |
|         å†…ç½®æ–¹æ³•         |        built in method         |
|         é€’å½’è°ƒç”¨         |         recursive call         |
|         åµŒå¥—å¯¹è±¡         |         nested object          |
| æ¨¡æ¿å­—ç¬¦ä¸²ï¼ˆæ¨¡æ¿å­—é¢é‡ï¼‰ |       template literals        |



